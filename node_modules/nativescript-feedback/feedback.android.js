"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const feedback_common_1 = require("./feedback.common");
exports.FeedbackType = feedback_common_1.FeedbackType;
exports.FeedbackPosition = feedback_common_1.FeedbackPosition;
const application = require("tns-core-modules/application");
const utils = require("tns-core-modules/utils/utils");
const color_1 = require("tns-core-modules/color");
class Feedback extends feedback_common_1.FeedbackCommon {
    constructor() {
        super(...arguments);
        this.lastAlert = null;
    }
    show(options) {
        return new Promise((resolve, reject) => {
            this.lastAlert = null;
            let alerter = com.tapadoo.alerter.Alerter.create(application.android.foregroundActivity)
                .setTitle(options.title)
                .setText(options.message)
                .setDuration(options.duration ? options.duration : 4000);
            if (options.icon) {
                let resourceId = Feedback.getIconResourceId(options.icon);
                if (resourceId === 0) {
                    console.log(`icon '${options.icon}' resource not found`);
                }
                else {
                    alerter.setIcon(resourceId);
                }
            }
            else {
                let resourcename = Feedback.getIconName(options.type);
                if (resourcename !== null) {
                    alerter.setIcon(Feedback.getIconResourceId(resourcename));
                }
                else {
                    alerter.showIcon(false);
                }
            }
            if (options.android && options.android.iconPulseEnabled !== undefined) {
                alerter.enableIconPulse(options.android.iconPulseEnabled);
            }
            if (options.titleFont) {
                const assetManger = utils.ad.getApplicationContext().getAssets();
                const fontPath = `app/fonts/${options.titleFont}`;
                const typeface = android.graphics.Typeface.createFromAsset(assetManger, fontPath);
                alerter.setTitleTypeface(typeface);
            }
            if (options.messageFont) {
                const assetManger = utils.ad.getApplicationContext().getAssets();
                const fontPath = `app/fonts/${options.messageFont}`;
                const typeface = android.graphics.Typeface.createFromAsset(assetManger, fontPath);
                alerter.setTextTypeface(typeface);
            }
            alerter.setOnClickListener(new android.view.View.OnClickListener({
                onClick: (view => {
                    this.lastAlert.hide();
                    if (options.onTap) {
                        options.onTap();
                    }
                })
            }));
            if (options.onShow) {
                alerter.setOnShowListener(new com.tapadoo.alerter.OnShowAlertListener({
                    onShow: () => options.onShow(),
                }));
            }
            if (options.onHide) {
                alerter.setOnHideListener(new com.tapadoo.alerter.OnHideAlertListener({
                    onHide: () => options.onHide(),
                }));
            }
            this.lastAlert = alerter.show();
            if (options.backgroundColor) {
                this.lastAlert.setAlertBackgroundColor(options.backgroundColor.android);
            }
            else {
                this.lastAlert.setAlertBackgroundColor(Feedback.getBackgroundColor(options.type).android);
            }
            if (options.titleColor) {
                let titleView = this.lastAlert.getTitle();
                titleView.setTextColor(options.titleColor.android);
            }
            if (options.messageColor) {
                let messageView = this.lastAlert.getText();
                messageView.setTextColor(options.messageColor.android);
            }
            const titleSize = options.titleSize || 16;
            const messageSize = options.messageSize || 13;
            this.lastAlert.getTitle().setTextSize(titleSize);
            this.lastAlert.getText().setTextSize(messageSize);
            if (options.android && options.android.iconColor) {
                let iconView = this.lastAlert.getIcon();
                iconView.setColorFilter(options.android.iconColor.android);
            }
            resolve();
        });
    }
    static getBackgroundColor(type) {
        if (type === undefined || type === null || type === feedback_common_1.FeedbackType.Custom) {
            return new color_1.Color("#73b7e8");
        }
        else if (type === feedback_common_1.FeedbackType.Warning) {
            return new color_1.Color("#f18b34");
        }
        else if (type === feedback_common_1.FeedbackType.Error) {
            return new color_1.Color("#ee664c");
        }
        else if (type === feedback_common_1.FeedbackType.Info) {
            return new color_1.Color("#516a78");
        }
        else {
            return new color_1.Color("#51ae8c");
        }
    }
    static getIconResourceId(resourcename) {
        let res = utils.ad.getApplicationContext().getResources();
        return res.getIdentifier(resourcename, "drawable", utils.ad.getApplication().getPackageName());
    }
    static getIconName(type) {
        if (type === undefined || type === null || type === feedback_common_1.FeedbackType.Custom) {
            return null;
        }
        else if (type === feedback_common_1.FeedbackType.Warning) {
            return "warningicon";
        }
        else if (type === feedback_common_1.FeedbackType.Error) {
            return "erroricon";
        }
        else if (type === feedback_common_1.FeedbackType.Info) {
            return "infoicon";
        }
        else {
            return "successicon";
        }
    }
    hide(options) {
        return new Promise((resolve) => {
            if (this.lastAlert !== null) {
                this.lastAlert.hide();
                this.lastAlert = null;
            }
            resolve();
        });
    }
}
exports.Feedback = Feedback;
